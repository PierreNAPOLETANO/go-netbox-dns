// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Record record
//
// swagger:model Record
type Record struct {

	// Active
	// Read Only: true
	Active *bool `json:"active,omitempty"`

	// address record
	AddressRecord *NestedRecord `json:"address_record,omitempty"`

	// Created
	// Read Only: true
	// Format: date-time
	Created *strfmt.DateTime `json:"created,omitempty"`

	// Custom fields
	CustomFields interface{} `json:"custom_fields,omitempty"`

	// Description
	// Max Length: 200
	Description string `json:"description,omitempty"`

	// Disable PTR
	//
	// Disable PTR record creation
	DisablePtr bool `json:"disable_ptr,omitempty"`

	// Display
	// Read Only: true
	Display string `json:"display,omitempty"`

	// ID
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// Last updated
	// Read Only: true
	// Format: date-time
	LastUpdated *strfmt.DateTime `json:"last_updated,omitempty"`

	// Managed
	Managed bool `json:"managed,omitempty"`

	// Name
	// Required: true
	// Max Length: 255
	// Min Length: 1
	Name *string `json:"name"`

	// ptr record
	PtrRecord *NestedRecord `json:"ptr_record,omitempty"`

	// Status
	// Enum: [active inactive]
	Status string `json:"status,omitempty"`

	// tags
	Tags []*NestedTag `json:"tags,omitempty"`

	// TTL
	// Maximum: 2.147483647e+09
	// Minimum: 0
	TTL *int64 `json:"ttl,omitempty"`

	// Type
	// Required: true
	// Enum: [A A6 AAAA AFSDB AMTRELAY APL AVC CAA CDNSKEY CDS CERT CNAME CSYNC DHCID DLV DNAME DNSKEY DS EUI48 EUI64 GPOS HINFO HIP HTTPS IPSECKEY ISDN KEY KX L32 L64 LOC LP MB MD MF MG MINFO MR MX NAPTR NID NINFO NS NSAP NSAP_PTR NSEC NSEC3 NSEC3PARAM NULL NXT OPENPGPKEY PTR PX RP RRSIG RT SIG SMIMEA SOA SPF SRV SSHFP SVCB TA TLSA TXT TYPE0 UNSPEC URI WKS X25 ZONEMD]
	Type *string `json:"type"`

	// Url
	// Read Only: true
	// Format: uri
	URL strfmt.URI `json:"url,omitempty"`

	// Value
	// Required: true
	// Max Length: 1000
	// Min Length: 1
	Value *string `json:"value"`

	// zone
	Zone *NestedZone `json:"zone,omitempty"`
}

// Validate validates this record
func (m *Record) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddressRecord(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePtrRecord(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateZone(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Record) validateAddressRecord(formats strfmt.Registry) error {
	if swag.IsZero(m.AddressRecord) { // not required
		return nil
	}

	if m.AddressRecord != nil {
		if err := m.AddressRecord.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("address_record")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("address_record")
			}
			return err
		}
	}

	return nil
}

func (m *Record) validateCreated(formats strfmt.Registry) error {
	if swag.IsZero(m.Created) { // not required
		return nil
	}

	if err := validate.FormatOf("created", "body", "date-time", m.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Record) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", m.Description, 200); err != nil {
		return err
	}

	return nil
}

func (m *Record) validateLastUpdated(formats strfmt.Registry) error {
	if swag.IsZero(m.LastUpdated) { // not required
		return nil
	}

	if err := validate.FormatOf("last_updated", "body", "date-time", m.LastUpdated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Record) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 255); err != nil {
		return err
	}

	return nil
}

func (m *Record) validatePtrRecord(formats strfmt.Registry) error {
	if swag.IsZero(m.PtrRecord) { // not required
		return nil
	}

	if m.PtrRecord != nil {
		if err := m.PtrRecord.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ptr_record")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ptr_record")
			}
			return err
		}
	}

	return nil
}

var recordTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recordTypeStatusPropEnum = append(recordTypeStatusPropEnum, v)
	}
}

const (

	// RecordStatusActive captures enum value "active"
	RecordStatusActive string = "active"

	// RecordStatusInactive captures enum value "inactive"
	RecordStatusInactive string = "inactive"
)

// prop value enum
func (m *Record) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, recordTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Record) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *Record) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	for i := 0; i < len(m.Tags); i++ {
		if swag.IsZero(m.Tags[i]) { // not required
			continue
		}

		if m.Tags[i] != nil {
			if err := m.Tags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Record) validateTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.TTL) { // not required
		return nil
	}

	if err := validate.MinimumInt("ttl", "body", *m.TTL, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("ttl", "body", *m.TTL, 2.147483647e+09, false); err != nil {
		return err
	}

	return nil
}

var recordTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["A","A6","AAAA","AFSDB","AMTRELAY","APL","AVC","CAA","CDNSKEY","CDS","CERT","CNAME","CSYNC","DHCID","DLV","DNAME","DNSKEY","DS","EUI48","EUI64","GPOS","HINFO","HIP","HTTPS","IPSECKEY","ISDN","KEY","KX","L32","L64","LOC","LP","MB","MD","MF","MG","MINFO","MR","MX","NAPTR","NID","NINFO","NS","NSAP","NSAP_PTR","NSEC","NSEC3","NSEC3PARAM","NULL","NXT","OPENPGPKEY","PTR","PX","RP","RRSIG","RT","SIG","SMIMEA","SOA","SPF","SRV","SSHFP","SVCB","TA","TLSA","TXT","TYPE0","UNSPEC","URI","WKS","X25","ZONEMD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recordTypeTypePropEnum = append(recordTypeTypePropEnum, v)
	}
}

const (

	// RecordTypeA captures enum value "A"
	RecordTypeA string = "A"

	// RecordTypeA6 captures enum value "A6"
	RecordTypeA6 string = "A6"

	// RecordTypeAAAA captures enum value "AAAA"
	RecordTypeAAAA string = "AAAA"

	// RecordTypeAFSDB captures enum value "AFSDB"
	RecordTypeAFSDB string = "AFSDB"

	// RecordTypeAMTRELAY captures enum value "AMTRELAY"
	RecordTypeAMTRELAY string = "AMTRELAY"

	// RecordTypeAPL captures enum value "APL"
	RecordTypeAPL string = "APL"

	// RecordTypeAVC captures enum value "AVC"
	RecordTypeAVC string = "AVC"

	// RecordTypeCAA captures enum value "CAA"
	RecordTypeCAA string = "CAA"

	// RecordTypeCDNSKEY captures enum value "CDNSKEY"
	RecordTypeCDNSKEY string = "CDNSKEY"

	// RecordTypeCDS captures enum value "CDS"
	RecordTypeCDS string = "CDS"

	// RecordTypeCERT captures enum value "CERT"
	RecordTypeCERT string = "CERT"

	// RecordTypeCNAME captures enum value "CNAME"
	RecordTypeCNAME string = "CNAME"

	// RecordTypeCSYNC captures enum value "CSYNC"
	RecordTypeCSYNC string = "CSYNC"

	// RecordTypeDHCID captures enum value "DHCID"
	RecordTypeDHCID string = "DHCID"

	// RecordTypeDLV captures enum value "DLV"
	RecordTypeDLV string = "DLV"

	// RecordTypeDNAME captures enum value "DNAME"
	RecordTypeDNAME string = "DNAME"

	// RecordTypeDNSKEY captures enum value "DNSKEY"
	RecordTypeDNSKEY string = "DNSKEY"

	// RecordTypeDS captures enum value "DS"
	RecordTypeDS string = "DS"

	// RecordTypeEUI48 captures enum value "EUI48"
	RecordTypeEUI48 string = "EUI48"

	// RecordTypeEUI64 captures enum value "EUI64"
	RecordTypeEUI64 string = "EUI64"

	// RecordTypeGPOS captures enum value "GPOS"
	RecordTypeGPOS string = "GPOS"

	// RecordTypeHINFO captures enum value "HINFO"
	RecordTypeHINFO string = "HINFO"

	// RecordTypeHIP captures enum value "HIP"
	RecordTypeHIP string = "HIP"

	// RecordTypeHTTPS captures enum value "HTTPS"
	RecordTypeHTTPS string = "HTTPS"

	// RecordTypeIPSECKEY captures enum value "IPSECKEY"
	RecordTypeIPSECKEY string = "IPSECKEY"

	// RecordTypeISDN captures enum value "ISDN"
	RecordTypeISDN string = "ISDN"

	// RecordTypeKEY captures enum value "KEY"
	RecordTypeKEY string = "KEY"

	// RecordTypeKX captures enum value "KX"
	RecordTypeKX string = "KX"

	// RecordTypeL32 captures enum value "L32"
	RecordTypeL32 string = "L32"

	// RecordTypeL64 captures enum value "L64"
	RecordTypeL64 string = "L64"

	// RecordTypeLOC captures enum value "LOC"
	RecordTypeLOC string = "LOC"

	// RecordTypeLP captures enum value "LP"
	RecordTypeLP string = "LP"

	// RecordTypeMB captures enum value "MB"
	RecordTypeMB string = "MB"

	// RecordTypeMD captures enum value "MD"
	RecordTypeMD string = "MD"

	// RecordTypeMF captures enum value "MF"
	RecordTypeMF string = "MF"

	// RecordTypeMG captures enum value "MG"
	RecordTypeMG string = "MG"

	// RecordTypeMINFO captures enum value "MINFO"
	RecordTypeMINFO string = "MINFO"

	// RecordTypeMR captures enum value "MR"
	RecordTypeMR string = "MR"

	// RecordTypeMX captures enum value "MX"
	RecordTypeMX string = "MX"

	// RecordTypeNAPTR captures enum value "NAPTR"
	RecordTypeNAPTR string = "NAPTR"

	// RecordTypeNID captures enum value "NID"
	RecordTypeNID string = "NID"

	// RecordTypeNINFO captures enum value "NINFO"
	RecordTypeNINFO string = "NINFO"

	// RecordTypeNS captures enum value "NS"
	RecordTypeNS string = "NS"

	// RecordTypeNSAP captures enum value "NSAP"
	RecordTypeNSAP string = "NSAP"

	// RecordTypeNSAPPTR captures enum value "NSAP_PTR"
	RecordTypeNSAPPTR string = "NSAP_PTR"

	// RecordTypeNSEC captures enum value "NSEC"
	RecordTypeNSEC string = "NSEC"

	// RecordTypeNSEC3 captures enum value "NSEC3"
	RecordTypeNSEC3 string = "NSEC3"

	// RecordTypeNSEC3PARAM captures enum value "NSEC3PARAM"
	RecordTypeNSEC3PARAM string = "NSEC3PARAM"

	// RecordTypeNULL captures enum value "NULL"
	RecordTypeNULL string = "NULL"

	// RecordTypeNXT captures enum value "NXT"
	RecordTypeNXT string = "NXT"

	// RecordTypeOPENPGPKEY captures enum value "OPENPGPKEY"
	RecordTypeOPENPGPKEY string = "OPENPGPKEY"

	// RecordTypePTR captures enum value "PTR"
	RecordTypePTR string = "PTR"

	// RecordTypePX captures enum value "PX"
	RecordTypePX string = "PX"

	// RecordTypeRP captures enum value "RP"
	RecordTypeRP string = "RP"

	// RecordTypeRRSIG captures enum value "RRSIG"
	RecordTypeRRSIG string = "RRSIG"

	// RecordTypeRT captures enum value "RT"
	RecordTypeRT string = "RT"

	// RecordTypeSIG captures enum value "SIG"
	RecordTypeSIG string = "SIG"

	// RecordTypeSMIMEA captures enum value "SMIMEA"
	RecordTypeSMIMEA string = "SMIMEA"

	// RecordTypeSOA captures enum value "SOA"
	RecordTypeSOA string = "SOA"

	// RecordTypeSPF captures enum value "SPF"
	RecordTypeSPF string = "SPF"

	// RecordTypeSRV captures enum value "SRV"
	RecordTypeSRV string = "SRV"

	// RecordTypeSSHFP captures enum value "SSHFP"
	RecordTypeSSHFP string = "SSHFP"

	// RecordTypeSVCB captures enum value "SVCB"
	RecordTypeSVCB string = "SVCB"

	// RecordTypeTA captures enum value "TA"
	RecordTypeTA string = "TA"

	// RecordTypeTLSA captures enum value "TLSA"
	RecordTypeTLSA string = "TLSA"

	// RecordTypeTXT captures enum value "TXT"
	RecordTypeTXT string = "TXT"

	// RecordTypeTYPE0 captures enum value "TYPE0"
	RecordTypeTYPE0 string = "TYPE0"

	// RecordTypeUNSPEC captures enum value "UNSPEC"
	RecordTypeUNSPEC string = "UNSPEC"

	// RecordTypeURI captures enum value "URI"
	RecordTypeURI string = "URI"

	// RecordTypeWKS captures enum value "WKS"
	RecordTypeWKS string = "WKS"

	// RecordTypeX25 captures enum value "X25"
	RecordTypeX25 string = "X25"

	// RecordTypeZONEMD captures enum value "ZONEMD"
	RecordTypeZONEMD string = "ZONEMD"
)

// prop value enum
func (m *Record) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, recordTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Record) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Record) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.FormatOf("url", "body", "uri", m.URL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Record) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", m.Value); err != nil {
		return err
	}

	if err := validate.MinLength("value", "body", *m.Value, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("value", "body", *m.Value, 1000); err != nil {
		return err
	}

	return nil
}

func (m *Record) validateZone(formats strfmt.Registry) error {
	if swag.IsZero(m.Zone) { // not required
		return nil
	}

	if m.Zone != nil {
		if err := m.Zone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("zone")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("zone")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this record based on the context it is used
func (m *Record) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActive(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAddressRecord(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDisplay(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePtrRecord(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateZone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Record) contextValidateActive(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "active", "body", m.Active); err != nil {
		return err
	}

	return nil
}

func (m *Record) contextValidateAddressRecord(ctx context.Context, formats strfmt.Registry) error {

	if m.AddressRecord != nil {
		if err := m.AddressRecord.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("address_record")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("address_record")
			}
			return err
		}
	}

	return nil
}

func (m *Record) contextValidateCreated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "created", "body", m.Created); err != nil {
		return err
	}

	return nil
}

func (m *Record) contextValidateDisplay(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "display", "body", string(m.Display)); err != nil {
		return err
	}

	return nil
}

func (m *Record) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *Record) contextValidateLastUpdated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "last_updated", "body", m.LastUpdated); err != nil {
		return err
	}

	return nil
}

func (m *Record) contextValidatePtrRecord(ctx context.Context, formats strfmt.Registry) error {

	if m.PtrRecord != nil {
		if err := m.PtrRecord.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ptr_record")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ptr_record")
			}
			return err
		}
	}

	return nil
}

func (m *Record) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tags); i++ {

		if m.Tags[i] != nil {
			if err := m.Tags[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Record) contextValidateURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "url", "body", strfmt.URI(m.URL)); err != nil {
		return err
	}

	return nil
}

func (m *Record) contextValidateZone(ctx context.Context, formats strfmt.Registry) error {

	if m.Zone != nil {
		if err := m.Zone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("zone")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("zone")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Record) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Record) UnmarshalBinary(b []byte) error {
	var res Record
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NestedRecord PTR record generated from an address
//
// swagger:model NestedRecord
type NestedRecord struct {

	// Active
	// Read Only: true
	Active *bool `json:"active,omitempty"`

	// Display
	// Read Only: true
	Display string `json:"display,omitempty"`

	// ID
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// Name
	// Required: true
	// Max Length: 255
	// Min Length: 1
	Name *string `json:"name"`

	// Status
	// Enum: [active inactive]
	Status string `json:"status,omitempty"`

	// TTL
	// Maximum: 2.147483647e+09
	// Minimum: 0
	TTL *int64 `json:"ttl,omitempty"`

	// Type
	// Required: true
	// Enum: [A A6 AAAA AFSDB AMTRELAY APL AVC CAA CDNSKEY CDS CERT CNAME CSYNC DHCID DLV DNAME DNSKEY DS EUI48 EUI64 GPOS HINFO HIP HTTPS IPSECKEY ISDN KEY KX L32 L64 LOC LP MB MD MF MG MINFO MR MX NAPTR NID NINFO NS NSAP NSAP_PTR NSEC NSEC3 NSEC3PARAM NULL NXT OPENPGPKEY PTR PX RP RRSIG RT SIG SMIMEA SOA SPF SRV SSHFP SVCB TA TLSA TXT TYPE0 UNSPEC URI WKS X25 ZONEMD]
	Type *string `json:"type"`

	// Url
	// Read Only: true
	// Format: uri
	URL strfmt.URI `json:"url,omitempty"`

	// Value
	// Required: true
	// Max Length: 1000
	// Min Length: 1
	Value *string `json:"value"`

	// zone
	Zone *NestedZone `json:"zone,omitempty"`
}

// Validate validates this nested record
func (m *NestedRecord) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateZone(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NestedRecord) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 255); err != nil {
		return err
	}

	return nil
}

var nestedRecordTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nestedRecordTypeStatusPropEnum = append(nestedRecordTypeStatusPropEnum, v)
	}
}

const (

	// NestedRecordStatusActive captures enum value "active"
	NestedRecordStatusActive string = "active"

	// NestedRecordStatusInactive captures enum value "inactive"
	NestedRecordStatusInactive string = "inactive"
)

// prop value enum
func (m *NestedRecord) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nestedRecordTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NestedRecord) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *NestedRecord) validateTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.TTL) { // not required
		return nil
	}

	if err := validate.MinimumInt("ttl", "body", *m.TTL, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("ttl", "body", *m.TTL, 2.147483647e+09, false); err != nil {
		return err
	}

	return nil
}

var nestedRecordTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["A","A6","AAAA","AFSDB","AMTRELAY","APL","AVC","CAA","CDNSKEY","CDS","CERT","CNAME","CSYNC","DHCID","DLV","DNAME","DNSKEY","DS","EUI48","EUI64","GPOS","HINFO","HIP","HTTPS","IPSECKEY","ISDN","KEY","KX","L32","L64","LOC","LP","MB","MD","MF","MG","MINFO","MR","MX","NAPTR","NID","NINFO","NS","NSAP","NSAP_PTR","NSEC","NSEC3","NSEC3PARAM","NULL","NXT","OPENPGPKEY","PTR","PX","RP","RRSIG","RT","SIG","SMIMEA","SOA","SPF","SRV","SSHFP","SVCB","TA","TLSA","TXT","TYPE0","UNSPEC","URI","WKS","X25","ZONEMD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nestedRecordTypeTypePropEnum = append(nestedRecordTypeTypePropEnum, v)
	}
}

const (

	// NestedRecordTypeA captures enum value "A"
	NestedRecordTypeA string = "A"

	// NestedRecordTypeA6 captures enum value "A6"
	NestedRecordTypeA6 string = "A6"

	// NestedRecordTypeAAAA captures enum value "AAAA"
	NestedRecordTypeAAAA string = "AAAA"

	// NestedRecordTypeAFSDB captures enum value "AFSDB"
	NestedRecordTypeAFSDB string = "AFSDB"

	// NestedRecordTypeAMTRELAY captures enum value "AMTRELAY"
	NestedRecordTypeAMTRELAY string = "AMTRELAY"

	// NestedRecordTypeAPL captures enum value "APL"
	NestedRecordTypeAPL string = "APL"

	// NestedRecordTypeAVC captures enum value "AVC"
	NestedRecordTypeAVC string = "AVC"

	// NestedRecordTypeCAA captures enum value "CAA"
	NestedRecordTypeCAA string = "CAA"

	// NestedRecordTypeCDNSKEY captures enum value "CDNSKEY"
	NestedRecordTypeCDNSKEY string = "CDNSKEY"

	// NestedRecordTypeCDS captures enum value "CDS"
	NestedRecordTypeCDS string = "CDS"

	// NestedRecordTypeCERT captures enum value "CERT"
	NestedRecordTypeCERT string = "CERT"

	// NestedRecordTypeCNAME captures enum value "CNAME"
	NestedRecordTypeCNAME string = "CNAME"

	// NestedRecordTypeCSYNC captures enum value "CSYNC"
	NestedRecordTypeCSYNC string = "CSYNC"

	// NestedRecordTypeDHCID captures enum value "DHCID"
	NestedRecordTypeDHCID string = "DHCID"

	// NestedRecordTypeDLV captures enum value "DLV"
	NestedRecordTypeDLV string = "DLV"

	// NestedRecordTypeDNAME captures enum value "DNAME"
	NestedRecordTypeDNAME string = "DNAME"

	// NestedRecordTypeDNSKEY captures enum value "DNSKEY"
	NestedRecordTypeDNSKEY string = "DNSKEY"

	// NestedRecordTypeDS captures enum value "DS"
	NestedRecordTypeDS string = "DS"

	// NestedRecordTypeEUI48 captures enum value "EUI48"
	NestedRecordTypeEUI48 string = "EUI48"

	// NestedRecordTypeEUI64 captures enum value "EUI64"
	NestedRecordTypeEUI64 string = "EUI64"

	// NestedRecordTypeGPOS captures enum value "GPOS"
	NestedRecordTypeGPOS string = "GPOS"

	// NestedRecordTypeHINFO captures enum value "HINFO"
	NestedRecordTypeHINFO string = "HINFO"

	// NestedRecordTypeHIP captures enum value "HIP"
	NestedRecordTypeHIP string = "HIP"

	// NestedRecordTypeHTTPS captures enum value "HTTPS"
	NestedRecordTypeHTTPS string = "HTTPS"

	// NestedRecordTypeIPSECKEY captures enum value "IPSECKEY"
	NestedRecordTypeIPSECKEY string = "IPSECKEY"

	// NestedRecordTypeISDN captures enum value "ISDN"
	NestedRecordTypeISDN string = "ISDN"

	// NestedRecordTypeKEY captures enum value "KEY"
	NestedRecordTypeKEY string = "KEY"

	// NestedRecordTypeKX captures enum value "KX"
	NestedRecordTypeKX string = "KX"

	// NestedRecordTypeL32 captures enum value "L32"
	NestedRecordTypeL32 string = "L32"

	// NestedRecordTypeL64 captures enum value "L64"
	NestedRecordTypeL64 string = "L64"

	// NestedRecordTypeLOC captures enum value "LOC"
	NestedRecordTypeLOC string = "LOC"

	// NestedRecordTypeLP captures enum value "LP"
	NestedRecordTypeLP string = "LP"

	// NestedRecordTypeMB captures enum value "MB"
	NestedRecordTypeMB string = "MB"

	// NestedRecordTypeMD captures enum value "MD"
	NestedRecordTypeMD string = "MD"

	// NestedRecordTypeMF captures enum value "MF"
	NestedRecordTypeMF string = "MF"

	// NestedRecordTypeMG captures enum value "MG"
	NestedRecordTypeMG string = "MG"

	// NestedRecordTypeMINFO captures enum value "MINFO"
	NestedRecordTypeMINFO string = "MINFO"

	// NestedRecordTypeMR captures enum value "MR"
	NestedRecordTypeMR string = "MR"

	// NestedRecordTypeMX captures enum value "MX"
	NestedRecordTypeMX string = "MX"

	// NestedRecordTypeNAPTR captures enum value "NAPTR"
	NestedRecordTypeNAPTR string = "NAPTR"

	// NestedRecordTypeNID captures enum value "NID"
	NestedRecordTypeNID string = "NID"

	// NestedRecordTypeNINFO captures enum value "NINFO"
	NestedRecordTypeNINFO string = "NINFO"

	// NestedRecordTypeNS captures enum value "NS"
	NestedRecordTypeNS string = "NS"

	// NestedRecordTypeNSAP captures enum value "NSAP"
	NestedRecordTypeNSAP string = "NSAP"

	// NestedRecordTypeNSAPPTR captures enum value "NSAP_PTR"
	NestedRecordTypeNSAPPTR string = "NSAP_PTR"

	// NestedRecordTypeNSEC captures enum value "NSEC"
	NestedRecordTypeNSEC string = "NSEC"

	// NestedRecordTypeNSEC3 captures enum value "NSEC3"
	NestedRecordTypeNSEC3 string = "NSEC3"

	// NestedRecordTypeNSEC3PARAM captures enum value "NSEC3PARAM"
	NestedRecordTypeNSEC3PARAM string = "NSEC3PARAM"

	// NestedRecordTypeNULL captures enum value "NULL"
	NestedRecordTypeNULL string = "NULL"

	// NestedRecordTypeNXT captures enum value "NXT"
	NestedRecordTypeNXT string = "NXT"

	// NestedRecordTypeOPENPGPKEY captures enum value "OPENPGPKEY"
	NestedRecordTypeOPENPGPKEY string = "OPENPGPKEY"

	// NestedRecordTypePTR captures enum value "PTR"
	NestedRecordTypePTR string = "PTR"

	// NestedRecordTypePX captures enum value "PX"
	NestedRecordTypePX string = "PX"

	// NestedRecordTypeRP captures enum value "RP"
	NestedRecordTypeRP string = "RP"

	// NestedRecordTypeRRSIG captures enum value "RRSIG"
	NestedRecordTypeRRSIG string = "RRSIG"

	// NestedRecordTypeRT captures enum value "RT"
	NestedRecordTypeRT string = "RT"

	// NestedRecordTypeSIG captures enum value "SIG"
	NestedRecordTypeSIG string = "SIG"

	// NestedRecordTypeSMIMEA captures enum value "SMIMEA"
	NestedRecordTypeSMIMEA string = "SMIMEA"

	// NestedRecordTypeSOA captures enum value "SOA"
	NestedRecordTypeSOA string = "SOA"

	// NestedRecordTypeSPF captures enum value "SPF"
	NestedRecordTypeSPF string = "SPF"

	// NestedRecordTypeSRV captures enum value "SRV"
	NestedRecordTypeSRV string = "SRV"

	// NestedRecordTypeSSHFP captures enum value "SSHFP"
	NestedRecordTypeSSHFP string = "SSHFP"

	// NestedRecordTypeSVCB captures enum value "SVCB"
	NestedRecordTypeSVCB string = "SVCB"

	// NestedRecordTypeTA captures enum value "TA"
	NestedRecordTypeTA string = "TA"

	// NestedRecordTypeTLSA captures enum value "TLSA"
	NestedRecordTypeTLSA string = "TLSA"

	// NestedRecordTypeTXT captures enum value "TXT"
	NestedRecordTypeTXT string = "TXT"

	// NestedRecordTypeTYPE0 captures enum value "TYPE0"
	NestedRecordTypeTYPE0 string = "TYPE0"

	// NestedRecordTypeUNSPEC captures enum value "UNSPEC"
	NestedRecordTypeUNSPEC string = "UNSPEC"

	// NestedRecordTypeURI captures enum value "URI"
	NestedRecordTypeURI string = "URI"

	// NestedRecordTypeWKS captures enum value "WKS"
	NestedRecordTypeWKS string = "WKS"

	// NestedRecordTypeX25 captures enum value "X25"
	NestedRecordTypeX25 string = "X25"

	// NestedRecordTypeZONEMD captures enum value "ZONEMD"
	NestedRecordTypeZONEMD string = "ZONEMD"
)

// prop value enum
func (m *NestedRecord) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nestedRecordTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NestedRecord) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *NestedRecord) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.FormatOf("url", "body", "uri", m.URL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *NestedRecord) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", m.Value); err != nil {
		return err
	}

	if err := validate.MinLength("value", "body", *m.Value, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("value", "body", *m.Value, 1000); err != nil {
		return err
	}

	return nil
}

func (m *NestedRecord) validateZone(formats strfmt.Registry) error {
	if swag.IsZero(m.Zone) { // not required
		return nil
	}

	if m.Zone != nil {
		if err := m.Zone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("zone")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("zone")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nested record based on the context it is used
func (m *NestedRecord) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActive(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDisplay(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateZone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NestedRecord) contextValidateActive(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "active", "body", m.Active); err != nil {
		return err
	}

	return nil
}

func (m *NestedRecord) contextValidateDisplay(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "display", "body", string(m.Display)); err != nil {
		return err
	}

	return nil
}

func (m *NestedRecord) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *NestedRecord) contextValidateURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "url", "body", strfmt.URI(m.URL)); err != nil {
		return err
	}

	return nil
}

func (m *NestedRecord) contextValidateZone(ctx context.Context, formats strfmt.Registry) error {

	if m.Zone != nil {
		if err := m.Zone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("zone")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("zone")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NestedRecord) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NestedRecord) UnmarshalBinary(b []byte) error {
	var res NestedRecord
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
